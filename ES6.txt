Let 
	Block level scope

Const
	cannot change, but arrays values can be modified. The reasons is const variable is just pointing the memory address and not the object value

Fat arrow Functions , shortest way of writing the functions
var fn = () => a+5
	if only one param can avoid the paranthesis
	can call in setTimeout(a => a + 5 , 1000); like this

"this" keyword in JS
	Unlike the traditional way this keyword will not point to the parent object. If called in fat arrow function it will be pointing to the very first parent object something like window.

params can be assign a value in arguments itself 
	e.g: function fn(n = 10, c = 20){..}

Object literals
	if variable assigned value earlier, object keys will look for them and get the values assigned.
	let name = 'Anna';
	let age = 25;
	let obj = {
		name,
		age
	}; 
	// [object object]{
		age : 25,
		name: 'Anna'
	}
Can assing object properties dynamically
 	let ageField = "age";
 	let obj = {
		name,
		[ageField] : 28
	};
	can call it obj.age or obj[ageField]

REST Operator - 
three dots before a param of function, when we dont know how many params wil be there 
	let numbers= [1,2,3,4,5];
	functin sumUp(...toAdd) {
		
	}
	sumUp(numbers);

SPREAD Operator -
three dots before a param, when we want to split array, but this time we are passing the three dots as argument
	let numbers= [1,2,3,4,5];
	Math.max(...numbers); //otherwise max function will expect list of arguments


LOOPS
for, do-while, while, for-in, and for-of

Template literals ``
can add multiline string 
	let name = 'Max'
	let description = `
		Hello I am ${name + "!"}
	`;

Destructuring Array
	let numbers = [1,2,3];

	traditionaly to extract values from array we would do something like:
		let a = numbers[0]; let b = numbers[1] .. n so on

	ES6
	let [a, b] = numbers; //will print 1, 2

Also can be used for swapping variables
	let a = 5; b = 10
	[b, a] = [a, b]; // b as 5 and a as 10

Destructuring objects
	let obj = {
		name: 'MAx',
		age: '27',
		greet: function(){
			console.log("Hello");
		}
	}
	let {name, greet} = obj;
	greet();

Generators 
	function* gen(){
		console.log("fruit");
	}
	to call this function need to call its next function like this
	var myGen = gen();
	myGen.next()

